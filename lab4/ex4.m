%
%% Курс Интеллектуальные системы (сентябрь 2019 - январь 2020)
%
%  Лабораторная работа 4.
%  Кластеризация методом k-средних. 
%
%  Инструкции
%  ------------
%
%  Файл содержит управляющий код, с помощью которого выполняется лабораторное упражнение.
%  Вам следует в процессе выполнения полного задания самостоятельно написать или дополнить некоторые 
%  модули, в частности:
%
%     findClosestCentroids.m
%     computeCentroids.m
%     kMeansInitCentroids.m
%
%  В процессе выполнения обязательной части задания в принципе нет необходимости в изменении кода ex4.m 
% (т.е. данного файла), или какого либо иного файла, кроме упомянутых.
%

%% Инициализация
clear ; close all; clc

%% ================= Часть 1: Нахождение ближайших центроидов ====================
%  С тем, чтобы Вы смогли эффективно изучить и применить метод k-средних, алгоритм обучения
%  реализван в виде двух функций - findClosestCentroids и computeCentroids. 
%  В этой части задания следует завершить код в программе findClosestCentroids. 
%
fprintf('Нахождение ближайших центров.\n\n');

% Загрузка данных из файла
load('ex4data.mat');

% Выбор начальных значений центроидов 
K = 3; 
% 3 центроида
initial_centroids = [3 3; 6 2; 8 5];

% Нахождение ближайших центроидов для выбранных элементов
idx = findClosestCentroids(X, initial_centroids);

fprintf('Ближайшие центры для 3-х первых примеров: \n')
fprintf(' %d', idx(1:3));
fprintf('\n(центры 1, 3, 2 соответственно).\n');

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;

%% ===================== Часть2: Вычисление средних =========================
%  После завершения моделирования с функцией, вычисляющей ближайшие центроиды,
%  следует правильно запрограммировать функцию computeCentroids.
%
fprintf('\nРасчет средних значений центров.\n\n');

%  Вычислите средние значения центров, основываясь на центроидах, найденных
%  в предыдущей части.
centroids = computeCentroids(X, idx, K);

fprintf('Перерасчет местоположения центров после нахождения ближайших центров: \n')
fprintf(' %f %f \n' , centroids');
fprintf('\nУказание: Ожидаемые значения центров\n');
fprintf('   [ 2.428301 3.157924 ]\n');
fprintf('   [ 5.813503 2.633656 ]\n');
fprintf('   [ 7.119387 3.616684 ]\n\n');

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;


%% =================== Часть 3: Кластеризация на основе метода k-средних ======================
%  После того, как запрограммированы две функции, а именно computeCentroids
%  и findClosestCentroids, имеется все необходимое для того, чтоббы реализовать собственно  
%  алгоритм k-средних. 
%  В данной части, следует промоделировать "K-Means" алгоритм на тестовом примере 
%  подготовленных произвольных данных. 
%
fprintf('\nВыполнение процедуры кластеризации методом k-средних на тестовом наборе данных.\n\n');

% Загрузка данных из файла
load('ex4data.mat');

% Начальные установки для реализации алгоритма
K = 3;
max_iters = 10;

% Для большей определенности (а также имея в виду методическую последовательность), ниже центроиды определены априорно,
% однако на практике, скорее всего, потребуется генерировать эти значения 
% произвольным образом, автоматически, в частности посредством задания случайных значений.
initial_centroids = [3 3; 6 2; 8 5];

% Моделирование алгоритма кластеризации методом k-средних. Значение 'true' в наборе аргументов 
% управляет выводом отображения процесса на экране (на графике)
%
[centroids, idx] = runkMeans(X, initial_centroids, max_iters, true);
%
fprintf('\nПроцедура кластеризации методом k-средних завершена.\n\n');

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;

%% ============= Часть 4: "K-means" кластеризация элементов изображения ===============
%  Терминология: пиксел (англ. pixel = picture element) обозначает элемент
%  изображения ("элиз")
%  В данном упражнении, следует применить процедуру кластеризации методом k-средних
%  для сжатия изображения. Для того, чтобы сделать это, "k-means" кластеризация 
%  производится в цветовом пространстве исходного изображения, а затем производится отображение 
%  на ближайшие центроиды в трансформированном цветовом пространстве.
%  
%  Требуется подготовить код функции kMeansInitCentroids.m
%

fprintf('\nВыполнение процедуры кластеризации методом k-средних на изображении.\n\n');

%  Загрузка изображения птицы
A = double(imread('bird_small.png'));

% Если загрузка не производится, можно воспользоваться процедурой
%   load ('bird_small.mat');

A = A / 255; 
% Осуществляется деление на 255 с целью нормировки всех данных в диапазоне от 0 до 1

% Размер изображения
img_size = size(A);

% Переопределение RGB изображения в матрицу Nx3, где N = количество элизов.
% Таким образом, каждая строка содержит сейчас значения компонент красного, зеленого и синего цветов
% В результате таких трансформаций, образована матрица X, которая будет использована в k-means.
X = reshape(A, img_size(1) * img_size(2), 3);

% приступить к исполнению алгоритма кластеризации k-means на полученных данных
% Следует использовать различные значени K и max_iters
K = 16; 
max_iters = 10;

% При  моделировании следует производить случайную начальную инициализацию центроидов. 
% Необходимо запрограммировать kMeansInitCentroids.m перед обработкой
initial_centroids = kMeansInitCentroids(X, K);

% Моделирование алгоритма
[centroids, idx] = runkMeans(X, initial_centroids, max_iters);

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;


%% ================= Часть 5: Сжатие изображения ======================
%  В этой части лабораторной работы Вы будете использовать 
%  метод кластеризации k-средних для сжатия изображения. 

fprintf('\nПрименение кластеризации методом k-средних для компрессии изображения.\n\n');

% Нахождение ближайших значений в кластере
idx = findClosestCentroids(X, centroids);

% Представление изображения X в терминах индексов в idx. 

% Восстановление изображения производится посредством отображения каждой точки изображения 
% (заданной посредством индексов в idx) на значения центроидов
X_recovered = centroids(idx,:);

% Преобразование формата изображения
X_recovered = reshape(X_recovered, img_size(1), img_size(2), 3);
figure;
% Отображение исходного изображения 
subplot(1, 2, 1);
imagesc(A); 
title('Оригинал');

% Отображение сжатого изображения
subplot(1, 2, 2);
imagesc(X_recovered)
title(sprintf('Сжатое с %d цветами', K));


fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;

%% Доп. задание

dir_name = 'images';
ext = ["png","jpg","bmp"];
imagefiles = [];
for i = 1:length(ext)
    dir(sprintf('%s/*.s', dir_name,ext(i)))
    imagefiles = [imagefiles;dir(sprintf('%s/*.%s', dir_name,ext(i)))];
end
nfiles = length(imagefiles);
for i=1:nfiles
    currentfilename = imagefiles(i).name;
    %  Загрузка изображения
    A = double(imread(fullfile(dir_name,currentfilename)));

    A = A / 255; 
    % Размер изображения
    img_size = size(A);

    % Переопределение RGB изображения в матрицу Nx3, где N = количество элизов.
    % Таким образом, каждая строка содержит сейчас значения компонент красного, зеленого и синего цветов
    % В результате таких трансформаций, образована матрица X, которая будет использована в k-means.
    X = reshape(A, img_size(1) * img_size(2), 3);

    % приступить к исполнению алгоритма кластеризации k-means на полученных данных
    % Следует использовать различные значени K и max_iters
    K = 16; 
    max_iters = 10;

    % При  моделировании следует производить случайную начальную инициализацию центроидов. 
    % Необходимо запрограммировать kMeansInitCentroids.m перед обработкой
    initial_centroids = kMeansInitCentroids(X, K);

    % Моделирование алгоритма
    [centroids, idx] = runkMeans(X, initial_centroids, max_iters);

    % Нахождение ближайших значений в кластере
    idx = findClosestCentroids(X, centroids);

    % Представление изображения X в терминах индексов в idx. 

    % Восстановление изображения производится посредством отображения каждой точки изображения 
    % (заданной посредством индексов в idx) на значения центроидов
    X_recovered = centroids(idx,:);

    % Преобразование формата изображения
    X_recovered = reshape(X_recovered, img_size(1), img_size(2), 3);

    % Отображение исходного изображения 
    figure;
    subplot(1, 2, 1);
    imagesc(A); 
    title('Оригинал');

    % Отображение сжатого изображения
    subplot(1, 2, 2);
    imagesc(X_recovered)
    title(sprintf('Сжатое с %d цветами', K));
    
    imwrite(X_recovered,sprintf('images/recovered/%s', currentfilename))
end
