%% Курс Интеллектуальные системы (сентябрь 2019 - январь 2020)
%  Лабораторная работа 1.1: Простая линейная регрессия 
%
%  Указание: Cкрипт, реализующий пошаговое выполнение задания по разделу
%            «Простая линейная регрессия»
%
%            В процессе выполнения задания следует доработать следующие коды (m-файлы):
%
%            warmUpExercise.m
%            plotData.m
%            gradientDescent.m
%            computeCost.m
%
%% Очистка памяти и удаление всех ранее открытых фигур
clear ; close all; clc

%% ==================== Задание 1: Простая функция MATLAB ====================
% Выполнение warmUpExercise.m 
fprintf('Выполнение warmUpExercise ... \n');
fprintf('5x5 Единичная матрица: \n');
warmUpExercise()

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;


%% ======================= Задание 2: Отображение данных на экране =======================
fprintf('Отображение данных в виде точечного графика ...\n')
data = load('ex1data1.txt');
X = data(:, 1); y = data(:, 2);
m = length(y); % Число данных обучающего набора

% Отображение данных
% Указание: Следует завершить код plotData.m
plotData(X, y);

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;

%% =================== Задание 3: Метод градиентного спуска ===================
fprintf('Выполнение градиентного спуска ...\n')

X = [ones(m, 1), data(:,1)]; % Добавление колонки единиц к x
theta = zeros(2, 1); 

% Некоторые начальные значения для метода градиентного спуска
iterations = 1500;
alpha = 0.01;

% Расчет и отображение начального значения функции стоимости
computeCost(X, y, theta)

% Выполнение градиентного спуска
theta = gradientDescent(X, y, theta, alpha, iterations);

% Отображение значения theta на экран
fprintf('Значение theta, полученное методом градиентного спуска: ');
fprintf('%f %f \n', theta(1), theta(2));

% Отображение линейной аппроксимации
hold on; % Сохранение предыдущей фигуры видимой
plot(X(:,2), X*theta, '-')
legend('Обучающие данные', 'Линейная регрессия')
hold off % Более не производить наложение других рисунков на эту фигуру

% Прогнозирование прибыли для количества проданных изделий 35,000 и 70,000
% (грубая оценка количества жителей города)
predict1 = [1, 3.5] *theta;
fprintf('Для количества изделий = 35,000, предсказываем прибыль %f\n',...
    predict1*10000);
predict2 = [1, 7] * theta;
fprintf('Для количества изделий = 70,000, предсказываем прибыль %f\n',...
    predict2*10000);

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;

%% ============= Задание 4: Визуализация J(theta_0, theta_1) =============
fprintf('Визуализация J(theta_0, theta_1) ...\n')

% Сетка, на которой рассчитывается J
theta0_vals = linspace(-10, 10, 100);
theta1_vals = linspace(-1, 4, 100);

% Инициализация J_vals to a matrix of 0's
J_vals = zeros(length(theta0_vals), length(theta1_vals));

% Заполнение J_vals
for i = 1:length(theta0_vals)
    for j = 1:length(theta1_vals)
	  t = [theta0_vals(i); theta1_vals(j)];    
	  J_vals(i,j) = computeCost(X, y, t);
    end
end


% производится транспонирование из-за особенности работы программы 
% surf
J_vals = J_vals';
% Отображение поверхности
figure;
surf(theta0_vals, theta1_vals, J_vals)
xlabel('\theta_0'); ylabel('\theta_1');

% Контурное представление
figure;
% Отображение J_vals в виде 15 контуров распределенных в 
% логарифмическом масштабе от 0.01 до 100
contour(theta0_vals, theta1_vals, J_vals, logspace(-2, 3, 20))
xlabel('\theta_0'); ylabel('\theta_1');
hold on;
plot(theta(1), theta(2), 'rx', 'MarkerSize', 10, 'LineWidth', 2);
