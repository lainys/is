%% Курс Интеллектуальные системы (сентябрь 2019 - январь 2020)
%
%  Инструкции
%  ------------
% 
%  Этот файл содержит код, который позволит выполнить Лабораторную работу,
%  касающуюся логистической регрессии. Следует запрограммировать следующие
%  функции
%
%     sigmoid.m
%     costFunction.m
%     predict.m
%     costFunctionReg.m
%
%  Для выполнения задания нет необходимости изменять какую либо часть кода,
%  которая имеется в данном файле или в иных файлах, которые не указаны в
%  задании. Однако, изменение некоторых параметров в процессе моделирования 
%  возможно (например,lambda).
%

%% Инициализация
clear ; close all; clc

%% Загрузка данных
%  Первые две столбца содержат оценочные данные, а третий столбец содержит
%  метку класса

data = load('ex2data2.txt');
X = data(:, [1, 2]); y = data(:, 3);

plotData(X, y);

hold on;

xlabel('Тест микросхем 1')
ylabel('Тест микросхем 2')

legend('y = 1', 'y = 0')
hold off;


%% =========== Задание 1(5): Регуляризованная логистическая регрессия ============
%  Указание: Исследуемые данные не являются линейно сепарабельными и, 
%  следовательно, не могут быть разделены на положительный и отрицательный 
%  классы прямой линией. Поэтому буквальное применение метода простой 
%  логистической регрессии не подходит в данном примере, поскольку он 
%  подразумевает прямолинейную границу раздела двух областей.
%  Тем не менее, использование логистической регрессии возможно, а именно,
%  посредством применения полиноминальных признаков, подобно полиноминальной регрессии. 

% Добавление полиноминальных признаков

% Указание: Функция mapFeature добавляет столбец единиц

X = mapFeature(X(:,1), X(:,2));

% Инициализация значений
initial_theta = zeros(size(X, 2), 1);

% Задание параметра регуляризации равным 1
lambda = 1;

% Вычисление и отображение начальных значений функции стоимости и
% градиента для регуляризованной логистической регрессии

[cost, grad] = costFunctionReg(initial_theta, X, y, lambda);

fprintf('Значение функции стоимости при начальном значении theta (zeros): %f\n', cost);

fprintf('Пауза в выполнении программы. Нажмите любую клавишу для продолжения.\n');
pause;

%% ============= Задание 2(6): Регуляризация и точность =============
%  Дополнительное задание:
%  В этом задании, варьируя значения lambda, выяснить влияние регуляризации на поведение 
%  границы разделения классов
%
%  Указание: Продемонстрировать эффект для lambda (0, 1, 10, 100).
%%

% Инициализация параметров
initial_theta = zeros(size(X, 2), 1);

lambdas = [0,1,10,50,100,500];
for i =1:length(lambdas)
    % Задание lambda (предополагается варьирование этого параметра)
    lambda = lambdas(i);

    % Задание опций
    options = optimset('GradObj', 'on', 'MaxIter', 400);

    % Оптимизация

    %[theta, J, exit_flag] = ...
    %fminunc(@(t)(costFunctionReg(t, X, y, lambda)), initial_theta, options);
    [theta, J, exit_flag] = ...
    	fmincg(@(t)(costFunctionReg(t, X, y, lambda)), initial_theta, options);

    % Отображение границы классов
    plotDecisionBoundary(theta, X, y);
    hold on;
    title(sprintf('lambda = %g', lambda))

    % Подписи
    xlabel('Тест микросхем 1')
    ylabel('Тест микросхем 2')

    legend('y = 1', 'y = 0', 'Граница')
    hold off;

    % Определяется точность тренировочного набора данных
    p = predict(theta, X);

    fprintf('Точность обучения: %f\n', mean(double(p == y)) * 100);
end


